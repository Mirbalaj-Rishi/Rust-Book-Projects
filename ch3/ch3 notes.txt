Scalar Types - single value
 -integer 
 -floating-point
 -numbers
 -booleans
 -characters
Notes on Scalar Types are not taken do to simularities with other languages

Compound Types
 - tuple - fixed size one declared - each element has a different type
    - let tub: (type) = (val) 
    - let tup: (i32, f64, u8) = (500, 6.4, 1); 
    - pull from tuple 
        //pull 6.4 from the tuple
        let tup = (500, 6.4, 1);
        //pattern matching in tuple 
        let (x, y, z) = tup;
        println!("The value of y is: {y}");
        //direct access 
        let six_point_four = x.1;
        println!("{six_point_four}");
 
 - array - fixed length - all the same type -stored in the stack
    - auto define type - let a = [1, 2, 3, 4, 5]; or manually define type - let a: [i32; 5] = [1, 2, 3, 4, 5];
    - let a = [3; 5]; result = [3,3,3,3,3]
    - access array elements based on index
        let a = [1, 2, 3, 4, 5];
        let one = a[0];
    


statement vs expresstion
- "Statements are instructions that perform some action and do not return a value."
    - let y = 6; since it does not return a value for example let x = (let y = 6); wont work
    - have a semicolen at the end ;
- "Expressions evaluate to a resultant value."
    - x + 1 since it returns what ever x is plus 1
    - no semicolen at the end 

three kinds of loops look in loops folder for more info
- loop
- while
- for